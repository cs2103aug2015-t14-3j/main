import java.util.ArrayList;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

abstract class Logic {

	abstract public String executeCommand(String command);

}

class TBLogic extends Logic {
	
	private String output;
	ArrayList<Map<String, String>> tasks;

	
	private Storage storage;
//	private History      ;
	private Parser parser;
	
	private Helper helper;
	private Adder adder;
	private Editor editor;
	private Displayer displayer;
	private Deleter deleter;
	private Searcher searcher;
	
	private final String INVALID_COMMAND = "Invalid Command\n";
	private final String INVALID_DISPLAY_SUB = "Invalid display subcommand specified\n";

	
	public TBLogic() {
		output = new String();
		parser = new Parser();
		
		storage = new Storage();
		
		helper = new Helper();
		adder = new Adder(storage);
		editor = new Editor(storage);
		displayer = new Displayer(storage);
		deleter = new Deleter(storage);
		searcher = new Searcher(storage);		
	}
	
	public String executeCommand(String command) {
		Map<String, String> parsedCommand = parser.getDictionary(command);
		
		String commandType = parsedCommand.get("command");
		
		//Edit this out; Used to check if contents of dictionary are correct
		System.out.println(parsedCommand.toString());
		
		switch (commandType) {
		case "add":
			output = adder.add(parsedCommand);
			return output;
		case "display":
			output = display(parsedCommand);
			return output;
		case "delete":
			output = delete(parsedCommand);
			return output;			
		case "edit":
			output = edit(parsedCommand);
			return output;
		case "search":
			output = search(parsedCommand);
			return output;
		case "undo":
			output = undo(parsedCommand);
			return output;
		case "help":
			output = help(parsedCommand);
			return output;
		default:
			return INVALID_COMMAND;
		}
	}
	
	private String display(Map<String, String> parsedCommand) {
		String subCommand = parsedCommand.get("subCommand");
		String date = parsedCommand.get("date");
		 
		
		if (subCommand == null) {
			//Display All
//			tasks = 
		} else {
			switch (subCommand) {
			case "on":
//				tasks = 
				break;
			case "from":
//				tasks = 
				break;
			case "after":
//				tasks = 
				break;
			case "due":
//				tasks = 
				break;
			case "incomplete":
//				tasks = 
				break;
			case "floating":
//				tasks = 
				break;
			default:
				return INVALID_DISPLAY_SUB;
			}
		}
		
//		output = String.format(DISPLAY_HEADER, "today");
//		int index = 1;
		
//		int i = 0;
		
//		for (i = 0; i < tasks.size(); ++i) {
//			Map<String,String> task = tasks.get(i);
			
//			String description = task.get("description");
//			String start = task.get("start");
//			String end = task.get("end");
			
//			output += String.format(DISPLAY_FORMAT, index, description, start, end);			
//		}
		
//		output += "\n";
//		return output;

		
		return "command: display " + "sub: " + subCommand + " date: " + date + "\n";
	}
	
	private String delete(Map<String,String> parsedCommand) {
		String index = parsedCommand.get("index");
		
		storage.delete(Integer.parseInt(index));
		
		return "command: delete " + "index: " + index + "\n";
	}
	
	private String edit(Map<String, String> parsedCommand) {
		String index = parsedCommand.get("index");
		String field = parsedCommand.get("field");
		String value = parsedCommand.get("value");
		
		switch (field) {
		case "description":
			storage.updateDescription(Integer.parseInt(index), value);
			break;
		case "start":
			LocalDateTime newValue = convertDateTime(value);
			storage.updateStartDate(Integer.parseInt(index), newValue);
		case "end":
			LocalDateTime newValue2 = convertDateTime(value);
			storage.updateEndDate(Integer.parseInt(index), newValue2);
			break;
		}
		
		return "command: edit " + "index: " + index + " field: " + field + " value: " + value + "\n";
	}
	
	private String search(Map<String, String> parsedCommand) {
		String searchKey = parsedCommand.get("searchKey");
		
		return "command: search " + " searchKey: " + searchKey + "\n";
	}
	
	private String undo(Map<String, String> parsedCommand) {
		return "command: undo\n";
	}
	
	private String help(Map<String, String> parsedCommand) {
		String target = parsedCommand.get("target");

		return helper.help(target);
		
//		return "help " + "target: " + target + "\n";
	}

}